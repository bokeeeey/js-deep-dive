# 27장 배열

## 1. 배열이란?

> 여러 개의 값을 순차적으로 나열한 자료구조

```jsx
const arr = ["apple", "banana", "orange"];
```

- 배열이 가지고 있는 값을 요소라고 부르며, 자바스크립트에서 값으로 인정하는 모든 것은 배열의 요소가 될 수 있다.

- 배열의 요소는 배열에서 자신의 위치를 나타내는 `0`이상의 정수인 인덱스를 가지며, 인덱스는 배열의 요소에 접근할 때 사용한다. 요소에 접근할 때는 접근하고 싶은 요소의 인덱스를 대괄호 내에 지정하는 대괄호 표기법을 사용한다.

- 요소의 개수를 나타내는 `length`프로퍼티를 갖는다.

- 배열은 인덱스와 `length`프로퍼티를 갖기 때문에 `for`문을 통해 순차적으로 요소에 접근할 수 있다.

- 배열은 객체 타입이며 배열 리터럴, `Array`생성자 함수, `Array.of`, `Array.from`메서드로 생성할 수 있다. 배열의 생성자 함수는 `Array`이며, 배열의 프로토타입 객체는 `Array.prototype`이다. `Array.prototype`은 배열을 위한 빌트인 메서드를 제공한다.

### 일반 객체와 배열의 특징

| 구분           | 객체                      | 배열          |
| -------------- | ------------------------- | ------------- |
| 구조           | 프로퍼티 키와 프로퍼티 값 | 인덱스와 요소 |
| 값의 참조      | 프로퍼티 키               | 인덱스        |
| 값의 순서      | ❌                        | ⭕️           |
| length프로퍼티 | ❌                        | ⭕️           |

<br />

## 2. 자바스크립트 배열은 배열이 아니다.

### 자료구조에서 말하는 배열:

- **밀집 배열**: 동일한 크기의 메모리 공간을 가진 요소가 빈틈없이 연속적으로 나열
- **임의 접근**: 인덱스를 통해 O(1) 시간 복잡도로 접근 가능.
- **단점**: 삽입 및 삭제 시 요소를 이동시켜야 하며, 검색 시 선형 검색이 필요함.

### 자바스크립트의 배열:

- **희소 배열**: 요소가 연속적으로 이어져 있지 않음
- 문자열을 프로퍼티 키로 가지는 인덱스와 `length` 프로퍼티를 가지는 특수한 객체
- **장점**: 요소 삽입 및 삭제가 비교적 빠름.
- **단점**: 인덱스를 통한 접근이 일반적인 배열보다 느릴 수 있음.

<br />

## 3. `length`프로퍼티와 희소 배열

### `length`프로퍼티

요소의 개수를 나타내는 0이상의 정수를 값으로 갖는다. `length`프로퍼티의 값은 빈 배열일 경우 0,빈 배열이 아닌 경우 가장 큰 인덱스에 1을 더한 것과 같고 배열의 요소가 추가되거나 삭제될 때 자동으로 갱신된다.

- 현재 `length`보다 **작은** 값 할당
  → 배열의 길이가 줄어든다.

```jsx
const arr = [1, 2, 3, 4, 5];

arr.length = 3;

console.log(arr); // [1, 2, 3]
```

- 현재 `length`보다 **큰** 값 할당
  → `length`프로퍼티 값은 변경되지만 실제 배열에는 아무런 변함이 없다.

```jsx
const arr = [1];

arr.length = 3;

console.log(arr.length); // 3
console.log(arr); // [1, empty * 2]
```

### 희소 배열

- **정의**: 요소가 연속적으로 위치하지 않고 일부가 비어 있는 배열
- **특성**: `length` 프로퍼티 값이 실제 요소의 개수보다 큼.
- **권장 사항**: 희소 배열은 성능에 좋지 않은 영향을 주기 때문에 배열에는 같은 타입의 요소를 연속적으로 위치시키는 것이 좋다.

<br />

## 4. 배열 생성

### 4-1. 배열 리터럴

> 가장 일반적이고 간편한 배열 생성 방식

```jsx
const arr = [1, 2, 3];
```

배열 리터럴은 `0`개 이상의 요소를 쉼표로 구분하여 대괄호(`[]`)로 묶는다. 배열 리터럴은 객체 리터럴과 달리 프로퍼티 키가 없고 값만 존재한다.

배열 리터럴에 요소를 하나도 추가하지 않으면 `length`프로터피 값이 `0`인 빈 배열이 되며, 요소를 생략하면 희소 배열이 생성된다.

### 4-2. `Array`생성자 함수

> 전달된 인수의 개수에 따라 다르게 동작

- 전달된 인수가 `1`개이고 숫자인 경우
  → `length`프로퍼티 값이 인수인 희소배열을 생성하며`length`프로퍼티 값은 `0`이 아니지만 실제로 배열의 요소는 존재하지 않는다.

```jsx
const arr = new Array(10);

console.log(arr); // [empty * 10]
console.log(arr.length); // 10
```

- 전달된 인수가 없는 경우
  → 빈 배열 생성

```jsx
new Array(); // -> []
```

- 전달된 인수가 `2`개 이상이거나 숫자가 아닌 경우
  → 인수를 요소로 갖는 배열 생성

```jsx
new Array(1, 2, 3); // [1, 2, 3]

new Array({}); // [{}]
```

---

- 일반 함수로서 호출하는 경우
  → `Array`생성자 함수는 내부에서 `new.target`을 확인하기 때문에 배열을 생성하는 생성자 함수로 동작한다.

```jsx
Array(1, 2, 3); // [1, 2, 3]
```

### 4-3. `Array.of`

> 전달된 인수를 요소로 갖는 배열 생성

전달된 인수가 `1`개이고 숫자이더라도 인수를 요소로 갖는 배열을 생성한다.

```jsx
Array.of(1); // [1]
Array.of(1, 2, 3); // [1, 2, 3]
Array.of("string"); // ['string']
```

### 4-4. `Array.from`

> 유사 배열 객체 또는 이터러블 객체를 인수로 전달받아 배열로 변환하여 반환

```jsx
Array.from({ length: 2, 0: "a", 1: "b" }); // ['a', 'b']

Array.from("Hello"); // ['H', 'e', 'l', 'l', 'o']
```

`Array.from`을 사용하면 두 번째 인수로 전달한 콜백 함수를 통해 값을 만들면서 요소를 채울 수 있다. 두 번째 인수로 전달한 콜백 함수에 첫 번째 인수에 의해 생성된 배열의 요소값과 인덱스를 순차적으로 전달하면서 호출하고, 콜백 함수의 반환값으로 구성된 배열을 반환한다.

```jsx
// length만 존재하는 유사 배열 객체를 전달하면 undefined를 요소로 채움
Array.from({ length: 3 }); // [undefined, undefined, undefined]

// 두 번째 인수로 전달한 콜백 함수의 반환값으로 구성된 배열을 반환
Array.from({ length: 3 }, (_, i) => i); // [0, 1, 2]
```

<br />

## 5. 배열 요소의 참조

배열의 요소를 참조할 때에는 대괄호(`[]`) 표기법을 사용한다. 대괄호 안에는 인덱스가 와야 한다. 정수로 평가되는 표현식이라면 인덱스 대신 사용할 수 있다. 인덱스는 값을 참조할 수 있다는 의미에서 객체의 프로퍼티 키와 같은 역할을 한다.

배열은 인덱스를 나타내는 문자열을 프로퍼티 키로 갖는 객체이기 때문에 존재하지 않는 요소를 참조하면 `undefined`를 반환한다.

<br />

## 6. 배열 요소의 추가와 갱신

존재하지 않는 인덱스를 사용해 값을 할당하면 새로운 요소가 추가된다. 이때 `length`프로퍼티 값은 자동 갱신된다.

현재 배열의 `length`프로퍼티 값보다 큰 인덱스로 새로운 요소를 추가하면 희소 배열이 된다. 이때 명시적으로 값을 할당하지 않은 요소이기 때문에 생성되지 않는다.

이미 존재하는 요소에 값을 재할당하면 요소값이 갱신된다.

인덱스는 반드시 0이상의 정수(또는 정수 형태의 문자열)를 사용해야 한다. 만약 정수 이외의 값을 사용하면 요소가 생성되는 것이 아니라 프로퍼티가 생성된다. 이때 추가된 프로퍼티는 `length`프로퍼티 값에 영향을 주지 않는다.

<br />

## 7. 배열 요소의 삭제

희소 배열을 만들지 않으면서 배열의 특정 요소를 완전히 삭제하려면 `Array.prototype.splice`메서드를 사용한다.

<br />

## 8. 배열 메서드

자바스크립트는 배열을 다룰 때 유용한 다양한 빌트인 메서드를 제공한다. `Array`생성자 함수는 정적 메서드를, 배열 객체의 프로토타입인 `Array.prototype`은 프로토타입 메서드를 제공한다.

배열에는 원본 배열을 직접 변경하는 메서드와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드가 있다.

원본 배열을 직접 변경하는 메서드는 부수 효과가 있으므로 가급적 원본 배열을 직접 변경하지 않는 메서드를 사용하는 편이 좋다.

### 8-1. `Array.isArray`

> `Array.of`와 `Array.from`과 같은 `Array`생성자 함수의 정적 메서드

전달된 인수가 배열이면 `true`, 배열이 아니면 `false`를 반환한다.

### 8-2. `Array.prototype.indexOf`

> 원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환

- 원본 배열에 인수로 전달한 요소와 중복되는 요소가 여러 개 있다면 첫 번째로 검색된 요소의 인덱스를 반환한다.
- 원본 배열에 인수로 전달한 요소가 존재하지 않으면 -1을 반환한다.

배열에 특정 요소가 존재하는지 확인할 때 유용하지만 `Array.prototype.includes`메서드를 사용하면 가독성이 더 좋다.

### 8-3. `Array.prototype.push`

> 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 `length`프로퍼티 값을 반환

`push`메서드는 성능 면에서 좋지 않고 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 `push`메서드보다는 ES6의 스프레드 문법을 사용하는 편이 좋다.

### 8-4. `Array.prototype.pop`

> 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환
> (원본 배열이 빈 배열이면 `undefined`를 반환)

`pop`메서드는 원본 배열을 직접 변경한다.

---

`pop`메서드와 `push`메서드를 사용하면 스택을 쉽게 구현할 수 있다.

스택은 데이터를 마지막에 밀어 넣고, 마지막에 밀어 넣은 최신 데이터를 먼저 꺼내는 후입 선출(LIFO - Last In First Out) 방식의 자료구조다.

- 푸시(push): 스택에 데이터를 밀어 넣는 것
- 팝(pop): 스택에서 데이터를 꺼내는 것

### 8-5. `Array.prototype.unshift`

> 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 `length`프로퍼티 값을 반환

원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 `unshift`메서드보다는 ES6의 스프레드 문법을 사용하는 편이 좋다.

### 8-6. `Array.prototype.shift`

> 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환
> (원본 배열이 빈 배열이면 `undefined`를 반환)

`shift`메서드는 원본 배열을 직접 변경한다.

---

`shift`메서드와 `push`메서드를 사용하면 큐를 쉽게 구현할 수 있다.

큐는 데이터를 마지막에 밀어 넣고 가장 먼저 밀어 넣은 데이터를 먼저 꺼내는 선입 선출(FIFO - First In First Out) 방식의 자료구조다. 스택은 언제나 마지막에 밀어 넣은 최신 데이터를 취득하지만 큐는 언제나 데이터를 밀어 넣은 순서대로 취득한다.

### 8-7. `Array.prototype.concat`

> 인수로 전달된 값들을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환,인수로 전달한 값이 배열인 경우 배열을 해제하여 새로운 배열의 요소로 추가

원본 배열은 변경되지 않는다.

---

#### `push`/`unshift`메서드와 `concat`메서드의 차이

- `push`와 `unshift`메서드
  - 원본 배열을 직접 변경
  - 인수로 전달받은 값이 배열인 경우 배열을 그대로 원본 배열의 마지막/첫 번째 요소로 추가
- `concat`메서드
  - 원본 배열을 변경하지 않고 새로운 배열을 반환
  - 인수로 전달받은 값이 배열인 경우 전달받은 배열을 해체하여 새로운 배열의 마지막 요소로 추가

`push`/`unshift`메서드와 `concat`메서드를 사용하는 대신 ES6의 스프레드 문법을 일관성 있게 사용하는 것을 권장한다.

### 8-8. `Array.prototype.splice`

> 원본 배열의 중간에 요소를 추가하거나 중간에 있는 요소를 제거하는 경우 사용

3개의 매개변수가 있으며 원본 배열을 직접 변경한다. 3개의 인수를 빠짐없이 전달하면 첫 번째 인수부터 두 번째 인수만큼 원본 배열에서 요소를 제거한다. 그리고 제거한 위치에 세 번째 인수를 원본 배열에 삽입한다.

```jsx
arr.splice(start, deleteCount, items);
```

#### start

> 원본 배열의 요소를 제거하기 시작할 인덱스

- start만 지정하면 원본 배열의 start부터 모든 요소를 제거한다.
- 음수인 경우 배열의 끝에서의 인덱스를 나타낸다.

#### deleteCount

> 원본 배열의 요소를 제거히기 시작할 인덱스인 start부터 제거할 요소의 개수

- 0인 경우 아무런 요소도 제거되지 않는다.

#### items

> 제거한 위치에 삽입할 요소들의 목록

- 생략할 경우 원본 배열에서 요소들을 제거하기만 한다.

---

배열에서 특정 요소를 제거하려면 `indexOf`메서드를 통해 특정 요소의 인덱스를 취득한 다음 `splice`메서드를 사용하거나, `filter`메서드를 사용하여 특정 요소를 제거할 수도 있지만 특정 요소가 중복된 경우 모두 제거된다.

### 8-9. `Array.prototype.slice`

> 인수로 전달된 범위의 요소들을 복사하여 배열로 반환

2개의 매개변수를 가지며 원본 배열은 변경되지 않는다. 첫 번째 인수로 전달받은 인덱스부터 두 번째 인수로 전달받은 인덱스 이전(end 미포함)까지 요소들을 복사하여 배열로 반환한다. 이때 생성된 복사본은 얕은 복사를 통해 생성된다.

```jsx
arr.slice(start, end);
```

#### start

> 복사를 시작할 인덱스

- 음수인 경우 배열의 끝에서의 인덱스를 나타낸다.

#### end

> 복사를 종료할 인덱스

- 이 인덱스에 해당하는 요소는 복사되지 않는다.
- 생략 가능하며 생략 시 기본값은 `length`프로퍼티 값이다.

`slice`메서드의 인수를 모두 생략하면 원본 배열의 복사본을 생성하여 반환한다.

---

`slice`메서드가 복사본을 생성하는 것을 이용하여 `arguments`, `HTMLCollection`, `NodeList`같은 유사 배열 객체를 배열로 변환할 수 있다.

`Array.from`메서드를 사용하면 더욱 간단하게 유사 배열 객체를 배열로 변환할 수 있다. `arguments`객체는 유사 배열 객체이면서 이터러블 객체다. 이터러블 객체는 ES6의 스프레드 문법을 사용하여 간단하게 배열로 변환할 수 있다.

### 8-10. `Array.prototype.join`

> 원본 배열의 모든 요소를 문자열로 변환한 후, 인수로 전달받은 문자열로 연결한 문자열을 반환

구분자는 생략 가능하며 기본 구분자는 콤마(’,’)다.

```jsx
const arr = [1, 2, 3, 4];

arr.join(); // '1,2,3,4'
arr.join(""); // '1234'
arr.join(":"); // '1:2:3:4'
```

### 8-11. `Array.prototype.reverse`

> 원본 배열의 순서를 반대로 뒤집어서 반환

원본 배열이 변경된다.

### 8-12. `Array.prototype.fill`

> 인수로 전달받은 값을 배열의 처음부터 끝까지 요소로 채운다.

원본 배열이 변경된다.

```jsx
arr.fill(value, start, end);
```

#### start

> 요소 채우기를 시작할 인덱스

#### end

> 요소 채우기를 멈출 인덱스

---

`fill`메서드를 사용하면 배열을 생성하면서 특정 값으로 요소를 채울 수 있지만 모든 요소를 하나의 값만으로 채울 수밖에 없다는 단점이 있다. 하지만 `Array.from`메서드를 사용하면 두 번째 인수로 전달한 콜백 함수를 통해 요소값을 만들면서 배열을 채울 수 있다.

### 8-13. `Array.prototype.includes`

> 배열 내에 특정 요소가 포함되어 있는지 확인하여 `true`또는 `false`를 반환

```jsx
arr.includes(searchElement, fromIndex);
```

#### searchElement

> 검색할 대상을 지정

#### fromIndex

> 검색을 시작할 인덱스

- 생략할 경우 기본값 0이 설정된다.
- 음수를 전달하면 `length`프로퍼티 값과 음수 인덱스를 합산하여(`length` + `index`) 검색 시작 인덱스를 설정한다.

---

`indexOf`메서드를 사용하여도 배열 내에 특정 요소가 포함되어 있는지 확인할 수 있다. 하지만 `indexOf`메서드를 사용하면 반환값이 -1인지 확인해 보아야 하고 배열에 NaN이 포함되어 있는지 확인할 수 없다는 문제가 있다.

### 8-14. `Array.prototype.flat`

> 인수로 전달한 깊이만큼 재귀적으로 배열을 평탄화

중첩 배열을 평탄화할 깊이를 인수로 전달할 수 있다. 인수를 생략할 경우 기본값은 1이다. 인수로 `Infinity`를 전달하면 중첩 배열 모두를 평탄화한다.

<br />

## 9. 배열 고차 함수

고차 함수는 함수를 인수로 전달받거나 함수를 반환하는 함수를 말한다. 자바스크립트의 함수는 일급 객체이므로 함수를 값처럼 인수로 전달하거나 반환할 수 있다. 고차 함수는 외부 상태의 변경이나 가변 데이터를 피하고 불변성을 지향하는 함수형 프로그래밍에 기반을 두고 있다.

함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 상태 변경을 피하려는 프로그래밍 패러다임이다. 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 하여 가독성을 해치고, 변수는 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있기 때문이다. 함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 일환이라고 할 수 있다.

자바스크립트는 고차 함수를 다수 지원하며, 특히 배열은 매우 유용한 고차 함수를 제공한다.

### 9-1. `Array.prototype.sort`

> 배열의 요소를 정렬, 원본 배열을 직접 변경하여 정렬된 배열을 반환

기본적으로 오름차순으로 요소를 정렬한다. 내림차순으로 요소를 정렬하려면 `sort`메서드를 사용하여 오름차순으로 정렬한 후 `reverse`메서드를 사용하여 요소의 순서를 뒤집는다.

숫자 요소를 정렬할 때는 `sort`메서드에 정렬 순서를 정의하는 비교 함수를 인수로 전달해야 한다. 비교 함수는 양수나 음수 또는 0을 반환해야 한다. 비교 함수의 반환값이 0보다 작으면 비교 함수의 첫 번째 인수를 우선하여 정렬하고, 0이면 정렬하지 않으며, 0보다 크면 두 번째 인수를 우선하여 정렬한다.

### 9-2. `Array.prototype.forEach`

> 반복문을 추상화한 고차 함수로서 내부에서 반복문을 통해 자신을 호출한 배열을 순회하면서 수행해야 할 처리를 콜백 함수로 전달받아 반복 호출

원본 배열(`this`)을 변경하지 않지만 콜백 함수를 통해 원본 배열을 변경할 수는 있으며, 반환값은 언제나 `undefined`다.

```jsx
arr.forEach(callbackFn, thisArg)

arr.forEach(callbackFn(currentValue[, index[, array]])[, thisArg])
```

`forEach`메서드는 콜백 함수를 호출할 때 메서드를 호출한 배열의 요소값과 인덱스, 메서드를 호출한 배열(`this`)을 순차적으로 전달한다.

내부에서는 반복문(`for`문)을 통해 배열을 순회할 수밖에 없다. 단, 반복문을 메서드 내부로 은닉하여 로직의 흐름을 이해하기 쉽게 하고 복잡성을 해결한다.

`for`문과는 달리 `break`, `continue`문을 사용할 수 없어서 배열의 모든 요소를 빠짐없이 모두 순회하며 중간에 순회를 중단할 수 없다.

희소 배열의 경우 존재하지 않는 요소는 순회 대상에서 제외된다.
(`map`, `filter`, `reduce`메서드 등에서도 마찬가지)

`for`문에 비해 성능이 좋지는 않지만 가독성은 더 좋다. 따라서 요소가 대단히 많은 배열을 순회하거나 시간이 많이 걸리는 복잡한 코드 또는 높은 성능이 필요한 경우가 아니라면 `for`문 대신 `forEach`메서드를 사용할 것을 권장한다. 더 나은 방법은 화살표 함수를 사용하는 것이다.

### 9-3. `Array.prototype.map`

> 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출하고 콜백 함수의 반환값들로 구성된 새로운 배열을 반환

원본 배열은 변경되지 않는다.

#### forEach메서드와 map메서드

- 공통점
  - 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출한다는 것
- 차이점
  - forEach: 언제나 undefined를 반환하며, 단순히 반복문을 대체하기 위한 고차함수
  - map: 콜백 함수의 반환값들로 구성된 새로운 배열을 반환하며, 요소값을 다른 값으로 매핑한 새로운 배열을 생성하기 위한 고차함수

```jsx
arr.map(callbackFn, thisArg)

arr.map(callbackFn(currentValue[, index[, array]])[, thisArg])
```

`map`메서드를 호출한 배열과 `map`메서드가 생성하여 반환한 배열을 1:1 매핑한다.

`map`메서드는 콜백 함수를 호출할 때 메서드를 호출한 배열의 요소값과 인덱스, 메서드를 호출한 배열(`this`)을 순차적으로 전달한다. 두 번째 인수로 `map`메서드의 콜백 함수 내부에서 `this`로 사용할 객체를 전달할 수 있다.

더 나은 방법은 화살표 함수를 사용하는 것이다.

### 9-4. `Array.prototype.filter`

> 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출하고 콜백 함수의 반환값이 `true`인 요소로만 구성된 새로운 배열을 반환

원본 배열은 변경되지 않는다.

자신을 호출한 배열에서 필터링 조건을 만족하는 특정 요소만 추출하여 새로운 배열을 만들고 싶을 때 사용한다. `filter`메서드가 생성하여 반환한 새로운 배열의 `length`프로퍼티 값은 `filter`메서드를 호출한 배열의 `length`프로퍼티 값과 같거나 작다.

```jsx
arr.filter(callbackFn, thisArg)

arr.filter(callbackFn(currentValue[, index[, array]])[, thisArg])
```

`filter`메서드는 콜백 함수를 호출할 때 `filter`메서드를 호출한 배열의 요소값과 인덱스, 메서드를 호출한 배열(`this`)을 순차적으로 전달한다. 두 번째 인수로 `filter`메서드의 콜백 함수 내부에서 `this`로 사용할 객체를 전달할 수 있다.

`filter`메서드는 자신을 호출한 배열에서 특정 요소를 제거하기 위해 사용할 수도 있다. 특정 요소를 제거할 경우 특정 요소가 중복되어 있다면 중복된 요소가 모두 제거된다. 특정 요소를 하나만 제거하려면 `indexOf`메서드를 통해 특정 요소의 인덱스를 취득한 다음 `splice`메서드를 사용한다.

더 나은 방법은 화살표 함수를 사용하는 것이다.

### 9-5. `Array.prototype.reduce`

> 자신을 호출한 배열을 모든 요소를 순회하며 인수로 전달받은 콜백 함수를 반복 호출하고 콜백 함수의 반환값을 다음 순회 시에 콜백 함수의 첫 번째 인수로 전달하면서 콜백 함수를 호출하여 하나의 결과값을 만들어 반환

원본 배열은 변경되지 않는다.

```jsx
arr.reduce(callbackFn[, initialValue])

arr.filter(callbackFn(accumulator[, currentValue[, currentIndex[, array]]])[, initialValue])
```

첫 번째 인수로 콜백 함수, 두 번째 인수로 초기값을 전달받는다. `reduce`메서드의 콜백 함수에는 4개의 인수, 초기값 또는 콜백 함수의 이전 반환값, 메서드를 호출한 배열의 요소값과 인덱스, 메서드를 호출한 배열(`this`)이 전달된다.

두 번째 인수로 전달하는 초기값은 첫 번째 순회에 콜백 함수의 첫 번째 인수로 전달된다. 초기값은 생략할 수 있지만 생략하지 말고 언제나 전달하는 것이 안전하다.

`reduce`메서드는 초기값과 배열의 첫 번째 요소값을 콜백 함수에게 인수로 전달하면서 호출하고 다음 순회에는 콜백 함수의 반환값과 두 번째 요소값을 콜백 함수의 인수로 전달하면서 호출한다. 이러한 과정을 반복하여 하나의 결과값을 반환한다.

자신을 호출한 배열의 모든 요소를 순회하며 하나의 결과값을 구해야 하는 경우에 사용한다.

`map`, `filter`, `some`, `every`, `find`같은 모든 배열의 고차 함수는 `reduce`메서드로 구현할 수 있다.

#### `reduce`메서드의 다양한 활용법

- 평균 구하기
- 최대값 구하기
- 요소의 중복 횟수 구하기
- 중첩 배열 평탄화
- 중복 요소 제거

### 9-6. `Array.prototype.some`

> 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하고 배열의 요소 중에 콜백 함수를 통해 정의한 조건을 만족하는 요소가 1개 이상 존재하는지 확인하여 그 결과를 불리언 타입으로 반환
> (단, 메서드를 호출한 배열이 빈 배열인 경우 언제나 `false`를 반환)

```jsx
arr.some(callbackFn, thisArg)

arr.some(callbackFn(element[, index[, array]])[, thisArg])
```

`some`메서드의 콜백 함수는 메서드를 호출한 요소값과 인덱스, 메서드를 호출한 배열(`this`)을 순차적으로 전달받을 수 있다.

두 번째 인수로 `some`메서드의 콜백 함수 내부에서 `this`로 사용할 객체를 전달할 수 있다. 더 나은 방법은 화살표 함수를 사용하는 것이다.

### 9-7. `Array.prototype.every`

> 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하고 배열의 모든 요소가 콜백 함수를 통해 정의한 조건을 모두 만족하는지 확인하여 그 결과를 불리언 타입으로 반환
> (단, 메서드를 호출한 배열이 빈 배열인 경우 언제나 `true`를 반환)

```jsx
every(callbackFn, thisArg)

every(callbackFn(element[, index[, array]])[, thisArg])
```

`every`메서드의 콜백 함수는 메서드를 호출한 요소값과 인덱스, 메서드를 호출한 배열(`this`)을 순차적으로 전달받을 수 있다.

두 번째 인수로 `every`메서드의 콜백 함수 내부에서 `this`로 사용할 객체를 전달할 수 있다. 더 나은 방법은 화살표 함수를 사용하는 것이다.

### 9-8. `Array.prototype.find`

> 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하여 반환값이 `true`인 첫 번째 요소를 반환
> (콜백 함수의 반환값이 `true`인 요소가 존재하지 않는다면 `undefined`를 반환)

```jsx
arr.find(callbackFn, thisArg)

arr.find(callbackFn(element[, index[, array]])[, thisArg])
```

`find`메서드의 콜백 함수는 메서드를 호출한 요소값과 인덱스, 메서드를 호출한 배열(`this`)을 순차적으로 전달받을 수 있다.

두 번째 인수로 `find`메서드의 콜백 함수 내부에서 `this`로 사용할 객체를 전달할 수 있다. 더 나은 방법은 화살표 함수를 사용하는 것이다.

### 9-9. `Array.prototype.findIndex`

> 자신을 호출한 배열의 요소를 순회하면서 인수로 전달된 콜백 함수를 호출하여 반환값이 `true`인 첫 번째 요소의 인덱스를 반환
> (콜백 함수의 반환값이 `true`인 요소가 존재하지 않는다면 -1을 반환)

```jsx
arr.findIndex(callbackFn, thisArg)

arr.findIndex(callbackFn(element[, index[, array]])[, thisArg])
```

`findIndex`메서드의 콜백 함수는 메서드를 호출한 요소값과 인덱스, 메서드를 호출한 배열(`this`)을 순차적으로 전달받을 수 있다.

두 번째 인수로 `findIndex`메서드의 콜백 함수 내부에서 `this`로 사용할 객체를 전달할 수 있다. 더 나은 방법은 화살표 함수를 사용하는 것이다.

### 9-10. `Array.prototype.flatMap`

> `map`메서드를 통해 생성된 새로운 배열을 평탄화
> → `map`메서드와 `flat`메서드를 순차적으로 실행하는 효과

단, `flatMap`메서드는 `flat`메서드처럼 인수를 전달하여 평탄화 깊이를 지정할 수는 없고 단 1단계만 평탄화한다. `map`메서드를 통해 생성된 중첩 배열의 평탄화 깊이를 지정해야 하면 `flatMap`메서드를 사용하지 말고 `map`메서드와 `flat`메서드를 각각 호출한다.
