# 24장 클로저

<br />

## Q. [유경] 클로저를 활용해야하는 이유를 캡슐화와 정보 은닉의 관점에서 설명해주세요.

### A.

- 프로퍼티와 프로퍼티의 값을 변경 또는 참조하는 메서드를 하나로 묶는 것을 의미합니다. 보통 특정 프로퍼티 및 메서드를 숨기기 위해서 이러한 캡슐화를 사용하는데, 이로 인해 객체 간의 상호 의존성, 즉 결합도를 낮출 수 있습니다. 결합도를 낮추는 것은 객체지향 프로그래밍에서 중요한 요소이기 때문에 이렇게 캡슐화를 통한 정보 은닉을 추구합니다.

- 클로저는 이러한 캡슐화를 도와주는 중요한 동작이므로 클로저를 활용하는 것이 좋습니다.

<br />

## Q. [보경] 렉시컬 스코프란 무엇인가요?

### A.

- 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값(상위 스코프)에 대한 참조는 함수 정의가 평가되는 시점에 함수가 정의된 위치에 의해 결정되는데 이를 렉시컬 스코프라고 한다.

<br />

## Q. [서인] 실행 컨텍스트 관점에서 클로저에 대해 설명해주세요.

### A.

- 클로저는 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명 주기가 종료한 외부 함수의 변수(식별자)를 참조할 수 있는 기능을 의미합니다.
- 함수가 실행될 때, 자바스크립트 엔진은 스코프 체인을 형성하고, 이를 통해 현재 함수에서 상위 함수의 변수에 접근할 수 있습니다.
- 상위 함수가 종료할 때 상위 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 A 함수의 렉시컬 환경까지 소멸하는 것은 아닙니다.
- 상위 함수의 렉시컬 환경은 참조되고 있을 때 가비지 컬렉션으로 소멸하지 않습니다. 따라서 상위 함수(외부 함수)가 소멸해도 반환된 중첩 함수는 외부 함수의 변수를 참조할 수 있습니다.

<br />

## Q. [유경] 아래의 코드 블록에서 makeCounter로 반환되는 값을 이야기하고 그 근거를 렉시컬 환경을 근거로 설명해주세요.

```js
function makeCounter(predicate) {
  let counter = 0;

  return function () {
    counter = predicate(counter);
    return counter;
  };
}

function increase(n) {
  n++;
}

function decrease(n) {
  n--;
}

const increaser = makeCounter(increase);
console.log(increaser()); // 1) ?
console.log(increaser()); // 2) ?
const decreaser = makeCounter(decrease);
console.log(decreaser()); // 3) ?
console.log(decreaser()); // 4) ?
```

### A.

`makeCounter` 함수가 실행되는 시점에 렉시컬 환경이 새로 만들어지기 때문에 `increaser`는 공통된 렉시컬 환경을 가지고 `decreaser`와는 또다른 렉시컬 환경을 가지기 때문에 `1`, `2`, `-1`, `-2`가 출력된다.
