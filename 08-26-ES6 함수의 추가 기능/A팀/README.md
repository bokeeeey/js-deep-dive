# 26장 ES6 함수의 추가 기능

## 1. 함수의 구분

ES6 이전의 모든 함수는 호출 방식과 생성자 함수로의 호출에 대한 명확한 구분이 없었다. 이러한 문제를 해결하기 위해 ES6에서는 함수를 사용 목적에 따라 세 가지 종류로 명확히 구분했다.

| ES6 함수의 구분    | constructor | prototype | super | arguments |
| ------------------ | ----------- | --------- | ----- | --------- |
| 일반 함수(Normal)  | ⭕️         | ⭕️       | ❌    | ⭕️       |
| 메서드(Method)     | ❌          | ❌        | ⭕️   | ⭕️       |
| 화살표 함수(Arrow) | ❌          | ❌        | ❌    | ❌        |

<br />

## 2. 메서드

ES6 사양에서 메서드는 메서드 축약 표현으로 정의된 함수만을 의미한다.

### 특징

- 인스턴스를 생성할 수 없는 `non-constructor`이기 때문에 생성자 함수로서 호출할 수 없다.
- 인스턴스를 생성할 수 없으므로 `prototype`프로퍼티가 없고 프로토타입도 생성하지 않는다.
- 내부 슬롯 `[[HomeObject]]`를 가지며, `super` 키워드를 사용할 수 있다.

<br />

## 3. 화살표 함수

`function` 대신 화살표(`=>`)를 사용하여 정의한다.

### 3-1. 화살표 함수 정의

- 함수 정의

화살표 함수는 함수 선언문으로 정의할 수 없고 함수 표현식으로 정의해야 한다. 호출 방식은 기존 함수와 동일하다.

```jsx
const multiply = (x, y) => x * y;

multiply(2, 3); // 6
```

- 매개변수 선언

매개변수가 여러 개인 경우 소괄호`()`안에 매개변수를 선언한다.

```jsx
const arrow = (x, y) => { ... };
```

매개변수가 한 개인 경우 소괄호`()`를 생략할 수 있다.

```jsx
const arrow = x => { ... };
```

매개변수가 없는 경우 소괄호`()`를 생략할 수 없다.

```jsx
const arrow = () => { ... };
```

- 함수 몸체 정의

함수 몸체가 하나의 문으로 구성된다면 함수 몸체를 감싸는 중괄호`{}`를 생략할 수 있다. 이때 함수 몸체 내부의 문이 값으로 평가될 수 있는 표현식인 문이라면 암묵적으로 반환된다.

```jsx
const power = (x) => x ** 2;
```

함수 몸체가 하나의 문으로 구성된다 해도 함수 몸체의 문이 표현식이 아닌 문이라면 중괄호를 생략할 수 없다.

```jsx
const arrow = () => {
  const x = 1;
};
```

객체 리터럴을 반환하는 경우 객체 리터럴의 중괄호`{}`를 함수 몸체를 감싸는 중괄호`{}`로 잘못 해석할 수 있어서 객체 리터럴을 소괄호`()`로 감싸 주어야 한다.

```jsx
const create = (id, content) => ({ id, content });
```

함수 몸체가 여러 개의 문으로 구성된다면 함수 몸체를 감싸는 중괄호`{}`를 생략할 수 없다. 이때 반환값이 있다면 명시적으로 반환해야 한다.

```jsx
const sum = (a, b) => {
  const result = a + b;
  return result;
};
```

화살표 함수도 즉시 실행 함수로 사용할 수 있다.

```jsx
const person = ((name) => ({
  sayHi() {
    return `Hi? My name is ${name}.`;
  },
}))("Lee");

console.log(person.sayHi()); // Hi? My name is Lee.
```

화살표 함수도 일급 객체이므로 `map`, `filter`, `reduce`같은 고차 함수에 인수로 전달할 수 있다. 이 경우 일반적인 함수 표현식보다 표현이 간결하고 가독성이 좋다.

```jsx
// ES5
[1, 2, 3].map(function (v) {
  return v * 2;
});

// ES6
[1, 2, 3].map((v) => v * 2); // [2, 4, 6]
```

### 3-2. 화살표 함수와 일반 함수의 차이

1. 화살표 함수는 인스턴스를 생성할 수 없는 `non-constructor`다.
2. 중복된 매개변수 이름을 선언할 수 없다.
3. 화살표 함수는 함수 자체의 `this`, `arguments`, `super`, `new.target`바인딩을 갖지 않는다.

### 3-3. `this`

#### 일반 함수

- `this` 바인딩은 함수 호출 방식에 따라 결정된다.
- 일반 함수로서 호출되는 모든 함수 내부에서의 `this`는 전역 객체를 가리키는데 클래스 내부의 모든 코드에 암묵적으로 적용된 `strict mode`에서는 `this`가 `undefined`로 바인딩된다.
- 콜백 함수의 `this`와 외부 함수의 `this`가 서로 다른 값을 가리키는 경우 TypeError가 발생할 수 있다.

#### 화살표 함수

- 함수 자체의 `this` 바인딩을 가지지 않는다.
- 상위 스코프의 `this`를 그대로 참조한다(`lexical this`).
- `this` 바인딩이 없는 화살표 함수 내부에서 `this`를 참조하면 상위 스코프에서 `this`를 탐색한다.
- 화살표 함수가 중첩되어 있는 경우 가장 가까운 상위 함수 중 화살표 함수가 아닌 함수의 `this`를 참조한다.
- `Function.prototype.call`, `Function.prototype.apply`, `Function.prototype.bind`메서드를 사용해도 화살표 함수 내부의 `this`를 교체할 수 없다.
- 화살표 함수로 메서드를 정의하는 것 ❌
  → ES6 메서드를 사용하는 것이 좋다.
- 프로토타입 객체의 프로퍼티에 화살표 함수를 할당하는 것 ❌
  → 일반 함수를 할당하거나, 객체 리터럴을 바인딩하고 프로토타입의 `constructor` 프로퍼티와 생성자 함수 간의 연결을 재설정한다.
- 클래스 필드에 화살표 함수를 할당할 수 있지만, 이 경우 화살표 함수는 인스턴스 메서드가 된다. 따라서 메서드를 정의할 때는 ES6 메서드를 사용하는 것이 좋다.

### 3-4. `super`

: ES6 메서드 내에서만 사용할 수 있는 키워드

화살표 함수는 함수 자체의 `super`바인딩을 갖지 않기 때문에 `super`를 참조하면 상위 스코프의 `super`를 참조한다.

### 3-5. `arguments`

화살표 함수는 함수 자체의`arguments` 바인딩을 가지지 않기 때문에 내부에서 `arguments`를 참조하면 상위 스코프의 `arguments`를 참조한다. 화살표 함수에서는 `arguments` 객체를 사용할 수 없으므로, 가변 인자 함수를 구현해야 할 때는 Rest 파라미터를 사용해야 한다.

<br />

## 4. Rest 파라미터

매개변수 이름 앞에 세개의 점`…`을 붙여서 정의한 매개변수

### 4-1. 기본 문법

- 함수에 전달된 인수들의 목록을 배열로 전달받는다.
- 일반 매개변수와 Rest 파라미터는 함께 사용할 수 있다. 이때 함수에 전달된 인수들은 매개변수와 Rest 파라미터에 순차적으로 할당된다.
- 반드시 마지막 파라미터이어야 한다.
- 단 하나만 선언할 수 있다.
- 함수 객체의 `length`프로퍼티에 영향을 주지 않는다.

### 4-2. Rest 파라미터와 `arguments`객체

ES6의 Rest 파라미터를 사용하면 가변 인자 함수의 인수 목록을 배열로 직접 전달받을 수 있어 `arguments`객체를 배열로 변환하는 번거로움을 피할 수 있다.

함수와 ES6 메서드는 Rest 파라미터와 `arguments`객체를 모두 사용할 수 있다. 하지만 화살표 함수는 함수 자체의 `arguments`객체를 갖지 않기 때문에 가변 인자 함수를 구현해야 할 때는 Rest 파라미터를 사용해야 한다.

<br />

## 5. 매개변수 기본값

ES6에서는 매개변수 기본값을 사용하여 매개변수에 인수를 전달하지 않거나 `undefined`를 전달한 경우 기본값을 설정할 수 있다. 이를 통해 함수 내에서 인수 체크 및 초기화 작업을 간소화할 수 있다. 매개변수 기본값은 함수 객체의 `length` 프로퍼티와 `arguments` 객체에 영향을 주지 않으며, Rest 파라미터에는 기본값을 지정할 수 없다.
