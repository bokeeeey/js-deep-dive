# 04장 변수

변수(variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

### 1. 동작원리

- 컴퓨터, 조금 더 정확히 표현하면 자바스크립트를 해석하고 실행하는 자바스크립트 엔진도 사람과 유사하게 코드를 실행한다.

- 코드를 계산하기 위해 연산자, 표현식 등의 의미를 해석(파싱)하며 CPU를 사용하여 연산하고, 메모리를 사용해 데이터를 기억한다.
- 값이 저장되는 각 셀은 고유의 메모리 주소를 갖는다. (ex. 0x0000000 ~ 0xFFFFFFF)
- 컴퓨터는 연산을 수행하는 과정에서 주어진 숫자값과 연산 결과로 생성되는 숫자값 모두 메모리 상의 임의의 위치에 저장하게 된다.
- 이때, 메모리에 저장되는 데이터는 데이터의 종류와 관계없이 모두 2진수로 저장된다.
- 연산을 마친 값 또한 메모리에 저장되지만 재사용하기 위해서는 연산결과가 저장된 메모리 공간에 직접 접근하여야 사용 가능하다.
- 하지만 이는 치명적 오류를 발생시킬 가능성이 매우 높은 위험한 행위이다. (따라서 자바스크립트는 개발자의 직접적인 메모리 제어를 허용하지 않음)
- 직접적인 접근을 하영하더라도 임의로 결정되는 메모리 주소를 추척하는것은 쉽지 않음
- 따라서 프로그래밍 언어는 기억하고 싶은 값을 메모리에 저장하고, 저장된 값을 읽어들여 재사용하기 위해 변수하는 메커니즘을 제공한다.

> 변수 = 저장된 값을 참조하는 메커니즘으로, 값의 위치를 가리키는 상징적인 이름

### 2. 식별자

- 변수 이름을 식별자(identifier) 라고도 한다.
- 식별자는 값이 아니라 메모리 주소를 기억하고 있다.
- 즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다.
- 변수, 함수, 클래스 등과 같이 메모리 상에 어떠한 값을 식별할 수 있는 이름은 모두 식별자 라고 부른다.
- 식별자는 네이밍 규칙을 준수해야 하며, 선언(declaration)에 의해 존재를 알린다.

> result (변수이름) === 0x0669F913 (메모리 주소) === 30 (저장된 값)

### 3. 변수 선언

- 변수 선언이란 값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 하는것이다.
- 변수선언에 의해 확보된 메모리 공간은 확보가 해제(release)되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호된다.

> 변수를 사용하려면 반드시 선언이 필요하다
> 변수를 선언할 때는 var, let, const 키워드를 사용한다.

#### 3-1. var 키워드

- 아직은 다뤄보지 않은 내용이지만 var 키워드는 여러 단점이 존재한다. 가장 대표적으로 block-level scope를 지원하지 않고 function-level scope를 지원한다는 것이다.
- 이로 인해 의도치 않게 전역 변수가 선언되어 부작용이 일어나기도 한다.

> 이러한 var 키워드의 여러 단점을 보완하기 위해서 ES6에서는 let과 const 키워드를 도입하였다.

#### 3-2. 예제 04-04

```js
var score; // 변수 선언
```

- 변수 선언문으로 변수 이름을 등록하고 메모리 공간을 확보
- 값이 할당되지 않은 메모리 공간은 비어있을 것으로 생각할 수 있으나 혹보된 메모리 공간에는 자바스크립트 엔진에 의해 `undefined`라는 값이 암묵적으로 할당되어 초기화된다. (자바스크립트의 특징)
- 자바스크립트 엔진은 변수 선언을 2단계에 거쳐 수행한다
  - 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알림
  - 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당해 초기화 한다.
- 만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전 사용 이력이 남아 있을 수 있다. === 쓰레기 값 (garbage value)
- 자바스크립트의 var 키워드는 암묵적으로 초기화를 수행하므로 이러한 위험으로부터 안전하다.
- 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러) 가 발생한다.

> ##### [ 🔎 ] 변수 이름은 어디에 등록되는가?
>
> 모든 식별자는 실행 컨텍스트에 등록된다.
>
> - 실행 컨텍스트는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.
> - 자바스크립트 엔진은 실행 컨텍스트를 통해 식별자와 스코프를 관리한다.
> - 변수 이름과 변수 값은 실행 컨텍스트 내에 key / value 형식인 객체로 등록되어 관리된다.

### 4. 변수 선언의 실행 시점과 변수 호이스팅

#### 4-1. 예제 04-05

```js
// 변수 선언문보다 변수를 참조하는 코드가 앞에 있는 경우
console.log(score); // undefined

var score; // 변수 선언문
```

인터프리터 언어인 자바스크립트는 한 줄씩 순차적으로 코드를 실행하므로 `console.log(score)`가 실행되는 시점에는 참조 에러(ReferenceError)가 발생할 것 처럼 보이지만 `undefined`가 출력된다.

> ⭐️ 이러한 현상의 이유는 변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.

- 자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 소스코드의 평가 과정을 거치면서 소스코드를 실행하기 위한 준비를 한다.
- 이때 소스코드 실행을 위한 준비 단계인 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스코드에서 찾아내 먼저 실행한다.
- 소스코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한 줄씩 순차적으로 실행한다.
- 즉, 자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관없이 다른 코드보다 먼저 실행하므로 어디에 위치하는지와 상관없이 어디서든지 변수를 참조할 수 있다.

> 이처럼 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(variable hoisting)이라 한다.

> 변수 선언뿐 아니라 var, let, const, function, function\*, class 키워드를 사용해서 선언하는 모든 식별자(변수, 함수, 클래스 등)는 호이스팅 된다. === 런타임 이전 단계에서 먼저 실행되기 때문

### 5. 값의 할당

#### 5-1. 예제 04-06 & 07

```js
var score; // 변수 선언
score = 80; // 값의 할당

또는;
var score = 80; //변수 선언과 값의 할당
```

자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 단축 표현해도 변수 선언과 값의 할당을 2개의 문으로 나누어 각각 실행한다.
이때 주의할 점은 변수 선언과 값의 할당의 실행 시점이 다르다는 것이다.
**변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 먼저 실행되지만 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**

#### 5-2. 예제 04-10

```js
console.log(score);

score = 80; // 값의 할당
var score; // 변수 선언

console.log(score);

// undefined
// 80
```

이미 메모리가 확보되고 초기화 되어있는 상태에서 값의 할당이 들어오므로 80으로 값이 나오는건가...?

### 6. 값의 재할당

- var 키워드로 선언한 변수는 값을 재할당 할 수 있다.
- var 키워드로 선언한 변수는 선언과 동시에 `undefined`로 초기화되기 때문에 처음으로 값을 할당하는 것도 사실은 재할당이다.
- 만약 값을 재할당 할 수 없으면 변수가 아닌 상수(constant)라 한다.
- 재할당으로 인해 어떠한 변수도 가지지 못하게 된 이전 값들은 아무도 사용하고 있지 않고 불필요한 값으로 남게 된다면 이러한 값들은 가비지 콜렉터에 의해 메모리에서 자동 해제된다. 단, 메모리에서 언제 해제된지는 예측할 수 없다.

> #### 가비지 콜렉터(garbage collector)
>
> 가비지 콜렉터는 애플리케이션이 할당(allocate)한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제(release)하는 기능을 말한다.

### 7. 식별자 네이밍 규칙

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러 기호($)를 포함할 수 있다.
- 단, 식별자는 특수문자를 제외한 문자, 언더스코어(\_), 달러 기호($)로 시작해야 한다. 숫자로 시작하는 것은 허용하지 않는다.
- 예약어는 식별자로 사용할 수 없다. === 프로그래밍 언어에서 사용되고 있거나 사용될 예정인 단어 (ex. const, var, let, null)

#### 7-1. 네이밍 컨벤션

네이밍 컨벤션은 하나 이상의 영어 단어로 구성된 식별자를 만들 때 가독성 좋게 단어를 한눈에 구분하기 위해 규정한 명명 규칙이다.

```js
// 카멜 케이스 camelCase
var firstName;

// 스네이크 케이스 snake_case
var first_name;

// 파스칼 케이스 PascalCase
var FirstName;

// 헝가리안 케이스 typeHungarianCase
var strFirstName; // type + identifier
var $elem = document.getElementById("myId"); // DOM 노드
var observable$ = fromEvent(document, "click"); // RxJS 옵저버블
```

자바스크립트에서는 일반적으로
변수나 함수의 이름에는 camelCase
생성자 함수, 클래스의 이름에는 PascalCase를 사용한다.
