# 45장 프로미스

> 비동기 처리 상태와 처리 결과를 관리하는 객체

프로미스는 비동기 처리를 위해 도입된 패턴으로 전통적인 콜백 패턴의 단점을 보완하고 비동기 처리 시점을 명확하게 표현할 수 있다는 장점이 있다.

<br />

## 1. 비동기 처리를 위한 콜백 패턴의 단점

### 1-1. 콜백 헬

비동기 함수에서 비동기 처리 결과를 반환하거나 상위 스코프 변수에 할당하려면, 해당 처리 결과에 대한 후속 처리는 함수 내부에서 수행해야 한다. 이 과정에서 콜백 함수 호출이 중첩되면 복잡도가 높아지는 현상이 발생하는데, 이를 **콜백 헬**이라고 한다.

### 1-2. 에러 처리의 한계

에러는 콜 스택의 아래 방향으로 전파된다. 하지만 비동기 함수의 콜백 함수를 호출한 것은 비동기 함수가 아니기 때문에 비동기 함수의 콜백 함수가 발생시킨 에러는 `catch` 블록에서 캐치되지 않아 에러 처리가 곤란하다.

<br />

## 2. 프로미스의 생성

`Promise` 객체는 `Promise` 생성자 함수를 `new` 연산자와 함께 호출하여 생성하며, 비동기 처리를 수행할 콜백 함수는 `resolve`와 `reject` 함수를 인수로 전달받는다.

`Promise` 생성자 함수가 인수로 전달받은 콜백 함수 내부에서 비동기 처리가 성공하면 `resolve`, 실패하면 `reject` 함수를 호출한다.

- 프로미스의 상태 정보
  | 프로미스의 상태 정보 | 의미 | 상태 변경 조건 | 비동기 처리 결과 |
  | --- | --- | --- | --- |
  | `pending` | 비동기 처리가 아직 수행되지 않은 상태 | 프로미스가 생성된 직후 기본 상태 | `undefined` |
  | `fulfilled` | 비동기 처리가 성공적으로 완료된 상태 | `resolve` 함수 호출 | 1 |
  | `rejected` | 비동기 처리가 실패한 상태 | `reject` 함수 호출 | Error 객체 |

`fulfilled` 또는 `rejected` 상태를 `settled` 상태라고 한다. 프로미스는 `pending` 상태에서 `settled` 상태로 변화할 수 있지만 `settled` 상태가 되면 더는 다른 상태로 변화할 수 없다.

<br />

## 3. 프로미스의 후속 처리 메서드

프로미스의 비동기 처리 상태가 변화하면 이에 따른 후속 처리를 위해 후속 메서드 `then`, `catch`, `finally`를 호출한다.

모든 후속 처리 메서드는 프로미스를 반환하며, 비동기로 동작한다.

### 3-1. `Promise.prototype.then`

```jsx
p.then(onFulfilled, onRejected);

p.then(
  function (value) {
    // 이행
  },
  function (reason) {
    // 거부
  }
);
```

#### onFulfilled(성공 처리 콜백 함수)

프로미스가 `fulfilled` 상태가 되면 호출되며, 프로미스의 비동기 처리 결과를 인수로 전달받는다.

#### onRejected(실패 처리 콜백 함수)

프로미스가 `rejected` 상태가 되면 호출되며, 프로미스의 에러를 인수로 전달받는다.

만약 `then` 메서드의 콜백 함수가 프로미스를 반환하면 그 프로미스를 그대로 반환하고, 프로미스가 아닌 값을 반환하면 그 값을 암묵적으로 `resolve` 또는 `reject`하여 프로미스를 생성해 반환한다.

### 3-2. `Promise.prototype.catch`

```jsx
p.catch(onRejected);
```

`catch`메서드의 콜백 함수는 프로미스가 `rejected` 상태인 경우만 호출된다.

### 3-3. `Promise.prototype.finally`

```jsx
p.finally(onFinally);
```

`finally` 메서드의 콜백 함수는 프로미스의 성공 또는 실패와 상관없이 무조건 한 번 호출된다.

프로미스의 상태와 상관없이 공통적으로 수행해야 할 처리 내용이 있을 때 유용하다.

<br />

## 4. 프로미스의 에러 처리

프로미스의 비동기 처리에서 발생한 에러는 `then` 메서드의 두 번째 콜백 함수로 처리하거나, `catch` 를 사용해 처리할 수 있다.

### `then`메서드

`then` 메서드의 두 번째 콜백 함수는 첫 번째 콜백 함수에서 발생한 에러를 캐치하지 못하고 코드가 복잡해져서 가독성이 좋지 않다.

### `catch`메서드

`catch` 메서드를 모든 `then` 메서드를 호출한 이후에 호출하면 비동기 처리에서 발생한 에러뿐만 아니라 `then` 메서드 내부에서 발생한 에러까지 모두 캐치할 수 있다.

`then` 메서드에 두 번째 콜백 함수를 전달하는 것보다 `catch` 메서드를 사용하는 것이 가독성이 좋고 명확하다.

<br />

## 5. 프로미스 체이닝

후속 처리 메서드는 언제나 프로미스를 반환하므로 연속적으로 호출할 수 있으며 이를 **프로미스 체이닝**이라 한다.

프로미스 체이닝을 통해 비동기 처리 결과를 전달받아 후속 처리를 하므로 콜백 헬이 발생하지 않는다.

<br />

## 6. 프로미스의 정적 메서드

`Promise`는 5가지 정적 메서드를 제공한다.

### 6-1. `Promise.resolve`/`Promise.reject`

> 이미 존재하는 값을 래핑하여 프로미스를 생성하기 위해 사용

#### `Promise.resolve`

인수로 전달받은 값을 `resolve`하는 프로미스를 생성한다.

#### `Promise.reject`

인수로 전달받은 값을 `reject`하는 프로미스를 생성한다.

### 6-2. `Promise.all`

> 여러 개의 비동기 처리를 모두 병렬 처리할 때 사용

프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받고, 전달받은 모든 프로미스가 모두 `fulfilled` 상태가 되면 모든 처리 결과를 배열에 저장해 새로운 프로미스를 반환한다.

인수로 전달받은 배열의 모든 프로미스가 모두 `fulfilled` 상태가 되면 종료하며, 처리 순서가 보장된다.

인수로 전달받은 배열의 프로미스가 하나라도 `rejected` 상태가 되면 나머지 프로미스가 `fulfilled` 상태가 되는 것을 기다리지 않고 즉시 종료한다.

인수로 전달받은 이터러블의 요소가 프로미스가 아닌 경우 `Promise.resolve` 메서드를 통해 프로미스로 래핑한다.

### 6-3. `Promise.race`

프로미스를 요소로 갖는 배열 등의 이터러블을 인수로 전달받고, 가장 먼저 `fulfilled` 상태가 된 프로미스의 처리 결과를 `resolve`하는 새로운 프로미스를 반환한다.

전달된 프로미스가 하나라도 `rejected` 상태가 되면 에러를 `reject`하는 새로운 프로미스를 즉시 반환한다.

### 6-4. `Promise.allSettled`

프로미스를 요소로 갖는 배열 등의 이러터블을 인수로 전달받고, 전달받은 프로미스가 모두 `settled` 상태가 되면 처리 결과를 배열로 반환한다.

반환한 배열에는 `fulfilled` 또는 `rejected` 상태와는 상관없이 인수로 전달받은 모든 프로미스들의 처리 결과가 모두 담겨 있다.

- 프로미스가 `fulfilled` 상태인 경우 비동기 처리 상태를 나타내는 `status` 프로퍼티와 처리 결과를 나타내는 `value` 프로퍼티를 갖는다.
- 프로미스가 `rejected` 상태인 경우 비동기 처리 상태를 나타내는 `status` 프로퍼티와 에러를 나타내는 `reason` 프로퍼티를 갖는다.

<br />

## 7. 마이크로태스크 큐

### 마이크로태스크 큐

프로미스의 후속 처리 메서드의 콜백 함수가 저장되는 큐

### 태스크 큐

그 외의 비동기 함수의 콜백 함수나 이벤트 핸들러가 일시 저장되는 큐

---

마이크로태스크 큐는 태스크 큐보다 우선순위가 높다. 즉, 이벤트 루프는 콜 스택이 비면 먼저 마이크로태스크 큐에서 대기하고 있는 함수를 가져와 실행한다. 이후 마이크로태스크 큐가 비면 태스크 큐에서 대기하고 있는 함수를 가져와 실행한다.

<br />

## 8. `fetch`

> HTTP 요청 전송 기능을 제공하는 클라이언트 사이드 Web API
> (`XMLHttpRequest` 객체보다 사용법이 간단하고 프로미스를 지원하기 때문에 비동기 처리를 위한 콜백 패턴의 단점에서 자유롭다.)

```jsx
const promise = fetch(url [, options])
```

`fetch` 함수에는 HTTP 요청을 전송할 URL과 HTTP 요청 메서드, HTTP 요청 헤더, 페이로드 등을 설정한 객체를 전달한다.

### `Response` 객체

> HTTP 응답을 나타내는 다양한 프로퍼티 제공

`fetch` 함수는`Response` 객체를 래핑한 프로미스를 반환하므로 후속 처리 메서드 `then`을 통해 프로미스가 `resolve`한 `Response` 객체를 전달받을 수 있다.

`Response.prototype`에는 `Response` 객체에 포함되어 있는 HTTP 응답 몸체를 위한 다양한 메서드를 제공한다. 예를 들어, `fetch` 함수가 반환한 프로미스가 래핑하고 있는 MIME 타입이 `application/json`인 HTTP 응답 몸체를 취득하려면 `Response.prototype.json` 메서드를 사용하여 HTTP 응답 몸체를 취득하여 역직렬화한다.

### 에러 처리

`fetch` 함수가 반환하는 프로미스는 HTTP 에러가 발생해도 에러를 `reject`하지 않고 불리언 타입의 ok 상태를 `false`로 설정한 `Response` 객체를 `resolve`한다. 따라서 `fetch` 함수를 사용할 때는 반환한 프로미스가 `resolve`한 불리언 타입의 ok 상태를 확인해 명시적으로 에러를 처리할 필요가 있다.
