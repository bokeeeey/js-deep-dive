# 45장 프로미스

## 1. 프로미스(Promise)란 무엇이며, 비동기 처리에서 사용되는 이유는 무엇인가요?

프로미스는 비동기 작업의 완료 또는 실패를 나타내는 객체입니다. 비동기 작업의 결과를 처리하는데 사용되며, 콜백 패턴의 단점을 보완합니다. 프로미스를 사용하면 비동기 코드의 가독성을 높이고, 비동기 작업의 성공 또는 실패를 명확하게 처리할 수 있습니다.

<br />

## 2. 마이크로태스크 큐와 태스크 큐의 차이점을 마이크로 태스크가 하는 일을 근거로 설명해주세요.

- **우선 순위**: 마이크로태스크는 태스크보다 우선적으로 실행됩니다. 이벤트 루프의 각 사이클에서 하나의 태스크가 완료되면, 다음 태스크로 넘어가기 전에 마이크로태스크 큐가 완전히 비워져야 합니다.
- **실행 시점**: 태스크는 이벤트 루프의 각 사이클에서 하나씩 실행됩니다. 반면, 마이크로태스크는 각 태스크가 끝난 후 즉시 실행되며, 태스크 실행을 지연시키지 않고 빠르게 처리됩니다.
- **주요 용도**: 마이크로태스크는 짧고 간단한 비동기 작업(주로 Promise 처리)에 사용됩니다. 태스크는 브라우저에서 발생하는 이벤트나 타이머와 같은 더 큰 비동기 작업에 사용됩니다.

<br />

## 3. 비동기 처리를 위한 콜백 패턴의 단점

- **콜백헬**
  - 비동기 처리 결과에 대한 후속 처리를 수행하는 비동기 함수가 비동기 처리 결과를 가지고 또다시 비동기 함수를 호출해야한다면 콜백 함수 호출이 중첩되어 복잡도가 높아지는 현상을 발생한다.
- **에러 처리**
  - 비동기 콜백 함수는 태스크 큐로 푸시되고 콜스택이 비어졌을 때 이벤트 루프에 의해 콜 스택으로 푸시되어 실행된다.
  - 예를 들어, try 코드 블록 내에서 호출한 setTimeout 함수의 콜백함수에서 에러가 발생하여도 catch 블록에서 캐치되지 않는다. 에러는 호출자 방향으로 전파가 되는데 콜백 함수를 호출한 것이 setTimeout 함수가 아니기 때문이다.

<br />

## 4. 프로미스의 세 가지 상태에 대해 설명하고, 각 상태에서 프로미스의 동작이 어떻게 달라지는지 설명해 주세요.

프로미스에는 **pending**, **fulfilled**, **rejected**의 세 가지 상태가 있습니다.

- **pending**: 비동기 작업이 아직 완료되지 않은 상태입니다.
- **fulfilled**: 비동기 작업이 성공적으로 완료된 상태입니다. 이 상태에서는 then 메서드를 통해 결과값을 처리할 수 있습니다.
- **rejected**: 비동기 작업이 실패한 상태입니다. 이 상태에서는 catch 메서드를 통해 에러를 처리할 수 있습니다. 한 번 fulfilled 또는 rejected 상태가 되면 더 이상 다른 상태로 변경되지 않습니다.

<br />

## 5. 프로미스 체이닝이란 무엇인가요?

프로미스 체이닝은 프로미스의 후속 처리 메서드가 프로미스를 반환하는 특성을 이용해 연속적으로 비동기 작업을 처리하는 방법입니다. 이를 통해 비동기 작업이 순차적으로 처리되도록 만들며, 콜백 헬을 방지할 수 있습니다.
