# [ 빌트인 객체 ]

# 자바스크립트 객체의 분류

## 1. 표준 빌트인 객체 (standard built-in objects / native objects / global objects)

- ECMAScript 사양에 정의된 객체를 말하며, 애플리케이션 전역의 공통 기능을 제공한다.
- 자바스크립트 실행 환경과 관계없이 언제나 사용할 수 있다.
- 전역 객체의 프로퍼티로서 제공됨
  <br />
  -> 별도의 선언 없이 전역 변수처럼 사용 가능

## 2. 호스트 객체 (host objects)

- ECMAScript 사양에 정의되어 있지 않지만, 자바스크립트 실행 환경 (브라우저 or Node.js 환경)에서 추가로 제공하는 객체
- 브라우저 환경 : DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker와 같은 클라이언트 사이드 Web API를 호스트 객체로 제공
- Node.js 환경 : Node.js 고유의 API를 호스트 객체로 제공

## 3. 사용자 정의 객체 (user-defined objects)

- 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 것이 아닌 사용자가 직접 정의한 객체

<br />

# 표준 빌트인 객체

- 자바스크립트는 40여 개의 표준 빌트인 객체를 제공한다.
- `Math`, `Reflect`, `JSON` 을 제외한 표준 빌트인 객체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체다.
  - 생성자 함수 객체인 빌트인 객체는 프로토타입 메서드와 정적 메서드를 제공하고,
  - 생성자 함수가 아닌 표준 빌트인 객체는 정적 메서드만 제공한다.
- 표준 빌트인 객체로 생성한 인스턴스는 빌트인 객체가 가진 prototype을 따라 가지게 된다.

```
  // String 생성자 함수에 의한 String 객체 생성
  const strObj = new String('Lee'); // String {"Lee"}

  // String 생성자 함수를 통해 생성한 strObj 객체의 프로토타입은 String.prototype이다.
  console.log(Object.getPrototypeOf(strObj) === String.prototype); // true
```

- 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체(String.prototype)는 다양한 기능의 빌트인 프로토타입 메서드를 제공한다.
  - 표준 빌트인 객체는 인스턴스 없이도 호출 가능한 빌트인 정적 메서드를 제공한다.

=> strObj는 String.prototype이 사용할 수 있는 정적 메서드를 상속 받아 사용할 수 있다. (slice, split 등)

<br />

# 원시값과 래퍼 객체

## 표준 빌트인 생성자 함수로 원시값을 생성해야 할까?

**그럴 필요가 없음**

-> 암묵적으로 래퍼 객체를 생성하기 때문

- 원시값은 객체가 아니기 때문에 프로퍼티나 메서드를 가질 수 없지만, 이들 원시값에 대해 객체 접근법 (마침표 or 대괄호 표기법)으로 접근하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시 값으로 되돌린다.

=> 원시값을 객체처럼 쓰면 잠깐 객체를 생성해서 쓰다가 다시 원상복귀 시킨다는 뜻

- 이때 생성되는 임시 객체를 래퍼 객체(wrapper object) 라고 한다.

```
const str = 'hi';

// 원시 타입인 문자열이 래퍼 객체인 String 인스턴스로 변환된다.
console.log(str.length); // 2
console.log(str.toUpperCase()); // HI

// 래퍼 객체로 프로퍼티에 접근하거나 메서드를 호출한 후, 다시 원시값으로 되돌린다.
console.log(typeof str); // string
```

- 래퍼 객체로의 접근 및 메서드 호출 시점에 식별자는 암묵적으로 생성된 래퍼 객체를 가리킨다.
- 접근 및 호출이 끝나면 식별자는 다시 원래의 원시값을 가리킨다.
  - 래퍼 객체는 이 시점에 가비지 콜렉터의 수집 대상이 된다. (참조하는 대상이 없기 때문)

## 결론

- 문자열, 숫자, 불리언, 심벌은 암묵적으로 생성되는 래퍼 객체에 의해 마치 객체처럼 사용할 수 있으며, 표준 빌트인 객체인 `String`, `Number`, `Boolean`, `Symbol`의 프로토타입 메서드 또는 프로퍼티를 참조할 수 있다.
  <br />
  -> 따라서 `String`, `Number`, `Boolean` 생성자 함수를 new 연산자와 함께 호출하여 인스턴스를 생성할 필요가 없으며 권장하지도 않는다.

- **<u>예외</u>** : `null`과 `undefined`는 래퍼 객체를 생성하지 않기 때문에 객체처럼 사용하면 에러가 난다.

<br />

# 전역 객체

: 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이자, 어떤 객체에도 속하지 않은 최상위 객체다.
<br />

```
전역 객체가 최상위 객체다. !== 프로토타입 상속 관계상에서 최상위 객체다
```

- 전역 객체 자신은 어떤 객체의 프로퍼티도 아니며 객체의 계층적 구조상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다는 것을 말한다.

## 전역 객체 식별자 명칭

- 브라우저 환경 : window (또는 self, this, frames)
- Node.js 환경 : global

<br />

> **globalThis**
> ES11에서 도입된 globalThis는 브라우저 환경과 Node.js 환경에서 전역 객체를 가리키던 다양한 식별자를 통일한 식별자이다.

## 전역 객체의 프로퍼티

- 표준 빌트인 객체 (Object, String, Number, Function, Array 등)
- 환경에 따른 호스트 객체 (클라이언트 Web API 또는 Node.js의 호스트 API)
- var 키워드로 선언한 전역 함수

## 전역 객체의 특징

- 전역 객체는 개발자가 의도적으로 생성할 수 없다. 즉, 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다.
- 전역 객체의 프로퍼티를 참조할 때 window (또는 global)을 생략할 수 있다.

- 여러 Script태그를 통해 분리를 해도 하나의 전역 객체를 공유한다.

## 빌트인 전역 프로퍼티

### `Infinity`

: Infinity 프로퍼티는 무한대를 나타내는 숫자값 Infinity를 갖는다.

- 음의 무한대와 양의 무한대가 있다.
- 숫자 타입이다.

### `NaN`

: NaN프로퍼티는 숫자가 아님 (Not-a-Number)을 나타내는 숫자값 NaN을 갖는다.

- Number.NaN 프로퍼티와 같음

### `undefined`

: undefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다.

## 빌트인 전역 함수

### `eval`

: eval 함수는 자바스크립트 코드를 나타내는 문자열을 인수로 전달받는다.

- 전달받은 문자열 코드가 문자열이면 문자열 코드를 런타임에 평가하여 값을 생성한다.
- 전달받은 인수가 표현식이 아닌 문이라면 문자열 코드를 런타임에 실행한다.
- 전달받은 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행한 후, 마지막 결과값을 반환한다.
- 자신이 호출된 위치에 해당하는 기존의 스코프를 런타임에 동적으로 수정한다.

```
  const x = 1;

  function foo(){
    // eval 함수는 런타임에 foo 함수의 스코프를 동적으로 수행한다.
    eval('var x = 2;');
    console.log(x); // 2
  }

  foo();
  console.log(x); // 1
```

- strict mode에서 eval 함수는 기존의 스코프를 수정하지 않고 eval 함수 자신의 자체적인 스코프를 생성한다.
- 인수로 전달받은 문자열 코드가 const, let 키워드를 사용한 변수 선언문이라면 암묵적으로 strict mode가 적용된다.

<u>**eval 함수의 부작용** </u>

- eval함수를 통해 사용자로부터 입력받은 콘텐츠를 실행하는 것은 보안에 매우 취약하다.
- 자바스크립트 엔진에 의한 최적화가 수행되지 않아 처리 속도가 실행에 비해 느리다.

=> **eval 함수 사용을 금지해야 한다.**

<br />

### `isFinite`

: 전달받은 인수가 정상적인 유한수인지 검사하여 true, false를 반환하는 함수다.

- 전달받은 인수의 타입이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다.
- 이때 인수가 NaN으로 평가되는 값이라면 false를 반환한다.
- null은 숫자로 변환하면 0이 된다.

### `isNaN`

: 전달받은 인수가 NaN인지 검사하여 그 결과를 불리언 타입으로 반환하는 함수다.

- 전달받은 인수의 타입이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다.

### `parseFloat`

: 전달받은 문자열 인수를 부동 소수점 숫자, 즉 실수로 해석하여 반환하는 함수다.

- 공백으로 구분된 문자열은 첫 번째 문자열만 변환한다.
- 변환할 수 없다면 NaN을 반환한다.
- 앞 뒤 공백은 무시된다.

### `parseInt`

: 전달받은 문자열 인수를 정수로 해석하여 반환하는 함수다.

- 전달받은 인수가 문자열이 아니면 문자열로 타입을 변환한 후 정수로 해석하여 반환한다.
- 두 번째 인수로 진법을 나타내는 기수를 전달할 수 있다.
  - 생략하면 10진수로 해석한다.
  - 0x / 0X로 시작하는 16진수 리터럴이라면 16진수로 해석하여 10진수 정수로 반환한다.
    - 2진수와 8진수 리터럴은 제대로 해석하지 못한다. (명시해줘야 함)

### `encodeURI` / `decodeURI`

: 완전한 URI를 문자열로 전달받아 이스케이프 처리를 위해 인코딩한다.

> **URI (Uniform Resource Identifier)** <br />
> : 인터넷에 있는 자원을 나타내는 유일한 주소 <br /> > \*\* 하위 개념으로 URL, URN이 있다.

> **인코딩** <br />
> : URI의 문자들을 이스케이프 처리하는 것

> **이스케이프 처리** <br />
> 네트워크를 통해 정보를 공유할 때 어떤 시스템에서도 읽을 수 있는 아스키 문자 셋으로 변환하는 것
>
> - 한글, 특수문자 등을 URI의 문법 형식 표준에 맞도록 변환하는 과정

- decodeURI는 이스케이프 처리하기 전으로 디코딩하는 함수다.

### `encodeURIComponent` / `decodeURIComponent`

: 함수의 URI 구성요소를 인수로 전달받아 인코딩하는 함수다.

- encodeURIComponent 함수는 인수로 전달되는 문자열을 URI의 구성요소인 쿼리 스트링의 일부로 간주하여 쿼리 스트링 구분자로 사용되는 =, ?, &까지 인코딩한다.
- encodeURI 함수는 매개변수로 전달된 문자열을 완전한 URI 전체라고 간주한다. 따라서 쿼리 스트링 구분자로 사용되는 =, ?, &은 인코딩하지 않는다.

<br />

## 암묵적 전역

: 선언되지 않은 변수에 값을 할당했을 때 전역 객체의 프로퍼티를 동적 생성하여 할당하는 것

- 변수 선언 없이 전역 객체의 프로퍼티로 추가되었기 때문에 변수 호이스팅이 일어나지 않는다.
- 변수가 아니기 때문에 delete 연산자로 삭제할 수 있다.
  - 전역 변수는 프로퍼티이지만 delete 연산자로 삭제할 수 없다.

```
  var x = 10; // 전역 변수

  function foo(){
    // 선언하지 않은 식별자에 값을 할당
    y = 20; // window.y = 20;
  }

  foo();
  // 선언하지 않은 식별자 y를 전역에서 참조할 수 있다.
  console.log(x + y); // 30
```
